# Концепцію замикання може добре пояснити приклад кешування значень функції.
#
# Підсумкове завдання модуля 3 було — рекурсивне обчислення чисел Фібоначчі.
#
# Ряд Фібоначчі - це послідовність чисел виду: 0, 1, 1, 2, 3, 5, 8, ..., де кожне наступне число
# послідовності виходить додаванням двох попередніх членів ряду.
#
# У загальному вигляді для обчислення n-го члена ряду Фібоначчі потрібно вирахувати вираз: Fn = Fn-1 + Fn-2.
#
# Це завдання можна вирішити рекурсивно, викликаючи функцію, що обчислює числа послідовності доти, доки виклик
# не сягне членів ряду менше n = 1, де послідовність задана.
#
# Створіть функцію caching_fibonacci(), яка матиме кеш із попередньо обчисленими значеннями чисел Фібоначі.
# Усередині вона містить функцію fibonacci(n), яка безпосередньо і обчислюватиме саме число Фібоначчі.
# Функція caching_fibonacci() повертає функцію fibonacci
#
# Якщо число Фібоначчі зберігається у словнику cache, то функція f ibonacci повертає число з кеша.
# Якщо його немає у кеші, то ми обчислюємо число і поміщаємо його в кеш, і повертаємо з функції fibonacci.

from time import time, sleep


def time_counter_decorator(func):
    def interval(*args, **kwargs):
        start = time()
        result = func(*args, **kwargs)
        passed = time() - start
        return passed, result
    return interval


@time_counter_decorator
def caching_fibonacci():
    cache = {0: 0,
             1: 1,
             2: 1}
    def fibonachi(n):
        if n in cache:
            return cache[n]
        else:
            a = fibonachi(n - 1) + fibonachi(n - 2)
            cache[n] = a
            return a

    return fibonachi




